Methodlar objelerinin içerisinde tanýmlanmýþ fonksiyonlardýr.

Örneðin my_string.upper bir fonksiyondur.
help(my_string.upper) dersen sana bu fonksiyonu açýklar.

Bir kütüphane belli bir iþlev için hazýrlanan fonksiyonlarýn topluluðudur.
Kütüphaneler bir dilin resmi tanýmýna dahil olabilir ve kurulumda beraber gelebilir (bu durumda onlara standart kütüphane denir), veya üçüncü kiþiler tarafýndan hazýrlanmýþ olabilir.

Aradaki nokta bir üyelik belirtir; sqrt fonksiyonu math modülünün altýndadýr.->math.sin(90)

Yükleme sýrasýnda modülün adýný deðiþtirebiliriz. Özellikle uzun isimli modülleri daha kýsa isimle kullanmak için bu özellik faydalý olur.
import math as m
print( m.sqrt(2) ) ---> 1.4142135623730951

Veya, modüldeki bütün isimlere ihtiyacýnýz yoksa, onlarý mevcut isim alanýnýza tek tek belirleyerek alabilirsiniz. Ýsim deðiþtirme burada da geçerlidir. Modül içindeki isimleri deðiþtirerek alabilirsiniz.
from math import sqrt, sin
from math import pi as (pi sembolü)
print( sqrt(2) ) ---> 1.4142135623730951
print( sin((pi sembolü)/2) ) ---> 1.0

\pi yazýp taba basarsan "(pi sembolu ama yazamadým)" ifadesini verir.

Baþka bir alternatif, modüldeki bütün isimleri mevcut isim alanýna yüklemektir.
from math import *
cos(pi), tan(pi/4)
Ancak bu usül Python programcýlarý tarafýndan tavsiye edilmez. Bir modül adý kullanmak, ister math ister kýsaca m, bir isim alaný yaratýr ve isim çatýþmalarýný engeller. Varsayalým ki pi veya tan deðiþkenlerini kodunuzda bir yerlerde önceden baþka bir anlamda tanýmladýnýz. Modülü import * ile yüklemekle önceki tanýmlarý silersiniz, ve kodunuz biraz karmaþýk ise bunu farketmeyebilirsiniz bile. Özellikle büyük modüllerde pek çok deðiþik isim gizli olabilir ve neyi sildiðinizi farketmeyebilirsiniz bile. En doðrusu, birazcýk daha fazla yazmayý göze alýp bir modül ismi kullanmaktýr. (* modüldeki her þeyi alýr.)

Bir modülde tanýmlý bütün isimlere dir fonksiyonuyla eriþilebilir.
import math
dir(math)
.
.
.



***help() iþlemi ile fonksiyonun içine gömülü belgeleme dizesi (docstring) ekrana yazýlýr.



***KENDÝ DOCSTRING ÝMÝZÝ OLUÞTURMAK
def fntoplam(f, a, b):
    """f(a) + f(a+1) + ... + f(b) toplamýný döndürür."""
    i = a
    toplam = 0
    while i<=b:
        toplam += f(i)
        i += 1
    return toplam


help(fntoplam)
Help on function fntoplam in module __main__:

fntoplam(f, a, b)
    f(a) + f(a+1) + ... + f(b) toplamýný döndürür.

BURADA ÖNEMLÝ OLAN FONKSÝYONDAN SONRA TIRNAK ÝÇÝNDE (TEK TIRNAK DA OLABÝLÝR) AÇIKLAMAYI YAZMIÞ OLMAMIZ.




Kendi fonksiyonumuzu nasýl yazarýz?
|||||||||||||||||||||||||||||||||||
def hello_world():
    print("hello")
    print("world")

s+e diyince bu fonksiyon tanýmlanmýþ olur.

hello_world ---s+e--->   <function __main__.hello_world()>

Diyor ki: main function içinde hello_world diye bir tanýmlama var.

hello_world() ---s+e---> hello
                         world

Fonksiyonlar bir girdi (input) alabilir, bir çýktý (output) döndürebilir (return edebilir).

INPUT&RETURN
||||||||||||
def hello_programming(name):
    print("hello")
    print(name)

hello_programming("Python") ---s+e---> hello
                                       Python

hello_programming("Java") ---s+e---> hello
                                     Java

hello_programming()---s+e---> ---------------------------------------------------------------------------
                              TypeError                                 Traceback (most recent call last)
                              <ipython-input-24-0ba20d50de35> in <module>
                              ----> 1 hello_programming()

                              TypeError: hello_programming() missing 1 required positional argument: 'name'





def hello_program(name="python"):                         PYTHON DEFAULT OLARAK VERÝLDÝ.
    print("hello")
    print(name)

hello_program() ---s+e---> hello
                           python

hello_program("Java") ---s+e---> hello
                                 Java




def summ(number1,number2):
    number3=number1+number2
    print(number3)

summ(5,8) ---s+e---> 13

my_integer=summ(5,8) ---s+e---> 13
my_integer ---s+e---> bir þey vermez
type(my_integer) ---s+e---> NoneType


def summation(num1,num2,num3):
    return num1+num2+num3

summation(10,20,30) ---s+e---> 60

my_result=summation(10,20,30) 

my_result ---s+e---> 60

 

def topla(e=2,r=3):
    return e+r

topla() ---s+e---> 5



def control_string(s):
    if s[0]=="m":
        print("mmm")

control_string("paris") ---s+e---> bir þey vermez
control_string("metallica") ---s+e---> mmm



def control_string(s):
    if s[0]=="m":
        print(s.capitalize())

control_string("metallica") ---s+e---> Metallica
control_string("james") ---s+e---> bir þey vermez
 


***return : Arkasýndan gelen ifadenin deðerinin, fonksiyonu çaðýran programa bildirilmesini saðlar ve fonksiyonun çalýþmasýný bitirir.



ARBITRARY (ÝSTEÐE BAÐLI) ARGUMENTS & KEY WORD ARGUMENTS
|||||||||||||||||||||||||||||||||||||||||||||||||||||||
_______________________________________________________
ARBITRARY ARGUMENTS

Kullanýcý kendi istediði kadar sayý yazýp toplasýn dersen ne yapacaksýn?


def summation_2(*args):
    return sum(args)

summation_2(10,20,30) ---s+e---> 60        KAÇ TANE VERÝRSEN VER TOPLAR




def my_func(*args):
    print(args)

my_func("2",2,"metal") ---s+e---> ('2', 2, 'metal')



*args ------> Sen ne verirsen onu alýr.
              Olay args da deðil yýldýzda.
              *args yerine *mert de yazsan aynýsý olur ama sen *args þeklinde kullan.
              Çünkü herkes *args þeklinde kullanýr.


__________________________________________________________
KEY WORD ARGUMENTS

Kullanýcýnýn istediði kadar anahtar kelimeyle girdi vermesini saðlayan iþlem.


def example_func(**kwargs):
    print(kwargs)


example_func(run=100,swim=200,basketball=300) ---s+e---> {'run': 100, 'swim': 200, 'basketball': 300}

example_func(a=1,b=2) ---s+e---> {'a': 1, 'b': 2}


def keyword_func(**kwargs):
    if "Metallica" in kwargs:
        print("Heavy Metalll!")
    else:
        print("Rock is dead")

keyword_func(Metallica=10,Madonna=5,Muslum=4)  ---s+e---> Heavy Metalll!

keyword_func(Madonna=8,Mickey=4) ---s+e---> Rock is dead



PRACTICAL FUNCTIONS
|||||||||||||||||||

def divide(number):
    return number/2

divide(10) ---s+e---> 5.0


my_list=[1,2,3,4,5,6,7,8]

for item in my_list:
    print(divide(item))  
0.5
1.0
1.5
2.0
2.5
3.0
3.5
4.0

my_new_list=[]
for item in my_list:
    my_new_list.append(divide(item))
print(my_new_list)
[0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0]


MAP
|||
Bir fonksiyonu bir iterable (içinde tek tek gezebileceðin liste,string gibi obje) üzerine uyarlamak.

map(divide,my_list) --s+e--> <map at 0xd3e25c8710>

list(map(divide,my_list)) --s+e--> [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0]


def control_string(string):
    if "Metallica" in string:
        return True

control_string("Metallicadkfjskj")
True

control_string("Metaskj") --s+e--> bir þey vermez



def control_string(string):
    return "Metallica" in string

control_string("Metallicadkfjskj")
True

control_string("Metaskj")
False


my_artist_list=["Metallica","Madonna","Queen","Megadeth","Muslum"]

list(map(control_string,my_artist_list)) ---s+e---> [True, False, False, False, False]


FILTER
||||||

list(filter(control_string,my_artist_list))
['Metallica']

TRUE OLANLARDAN LÝSTE YAPAR.


LAMBDA
||||||
Genelde tek kullanýmlýk fonksiyonlarda kullanýlýr.

***def multiply(number):return number*3 ---> Fonksiyon bu þekilde tek satýrda da yazýlabilir.

multiply=lambda number:number*3

multiply(5)
15


Nerede iþe yarar:     my_list_3=[3,5,7,9]

                      list(map(lambda num:num*4,my_list_3))
                      [12, 20, 28, 36]

Sýrf map'in ilk kýsmý için ayrý satýrda özel bir fonksiyon kullanmamak için lambda'yý kullandýk.


SCOPE (KAPSAM)
||||||||||||||
number=10
def multiply(num):
    number=5
    return num*number

multiply(10) ---s+e---> 50

print(number) ---s+e---> 10



LEGB
L -> Local
E -> Enclosing
G -> Global
B -> Built-in
__________________
||||||||||||||||||


#Global
my_string="Mert"

def my_func():
    
    #Enclosing
    my_string="James"
    
    def my_func_2():
        
        #Local
        my_string="Lars"
        print(my_string)
        
    my_func_2()            ---------> Baþýna return de yazabilirdin.



my_func ---s+e---> Lars

my_string ---s+e---> 'Mert'



Python bir variable'a bakarken önce local olarak tanýmlanýp tanýmlanmadýðýna bakar.
Local'de yoksa bir üste (Enclosing function) bakar.
Eðer orada da yoksa global'a bakar.
Bulamadýysa built-in'lere (python'un kendi deðiþkenlerine) de hata vermeden önce bakar.

Built-in -----> help, len, max gibi yazýnca yeþile dönen; daha önceden tanýmlanmýþ fonksiyonlar.



y=10
def func_new(y):
    print(y)
    y=5
    print(y)
    return y
	
func_new(4) ---s+e---> 4
                       5

                       5

y ---s+e---> 10




Global y deðiþsin istersek:
___________________________

y=func_new(y) ---s+e---> 10
                         5

y ---s+e---> 5


y=10
def func_2():
    global y
    y=5
    print(y)

func_2() ---s+e---> 5

y ---s+e---> 5



DECORATORS
||||||||||

def func(new_func):
    print("func started")
    new_func()
    print("func ended")

def hello_func():
    print("hello world")

func(hello_func) ---s+e---> func started
                            hello world
                            func ended



def new_function():
    def new_function_2():
        print("new_function_2")

new_function() ---s+e---> Bir þey vermez.

new_function_2() ---s+e---> Hata verir.



def new_function():
    def new_function_2():
        print("new function 2")
    new_function_2()                         Baþýna return de ekleyebilirsin.

new_function() ---s+e---> new function 2

new_function_2() ---s+e---> Yine hata verir.




def new_function():
    def new_function_2():
        print("new function 2")
    return new_function_2


new_function() ---s+e---> <function __main__.new_function.<locals>.new_function_2()>
                          Bana new_function_2'yi döndürdü diyor ama bir þey vermiyor.


string_new=new_function()

string_new ---s+e---> <function __main__.new_function.<locals>.new_function_2()>

string_new() ---s+e---> new function 2






def new_function():
    print("new func")
    def new_function_2():
        print("new function 2")
    return new_function_2

string_new=new_function() ---s+e---> new func

string_new ---s+e---> <function __main__.new_function.<locals>.new_function_2()>

string_new() ---s+e---> new function 2

new_function() ---s+e---> new func
                          <function __main__.new_function.<locals>.new_function_2()>





def decorator_function(func):
    def wrapper_function():
        print("wrapper started")
        func()
        print("wrapper stopped")
    return wrapper_function

def func_new():
    print("hello world")

decorater_function(func_new)() ---s+e---> wrapper started     YA DA  return wrapper_function()  YA DA   example_function = decorator_function(func_new)
                                          hello world                yazsaydýn ekstradan ()             
                                          wrapper stopped            bunlara gerek kalmazdý.            example_function() --s+e--> wrapper started
                                                                                                                                    hello world
                                                                                                                                    wrapper stopped


@decorator_function
def func_new():
    print("hello world")

func_new() ---s+e---> wrapper started
                      hello world
                      wrapper stopped



def func(num):
    a=num*3
    return a

func(4)--->12

x=func(4) ---> Bir þey yok.

x--->12

type(x)--->int



def func_2(numb):
    b=numb*3
    print(b)

func_2(4) ---> 12

y=func_2(4) --->12

y ---> Bir þey yok.

type(y)--->NoneType



BÝR DEÐÝÞKENÝ FONKSÝYONA EÞÝTLEDÝÐÝNDE FONKSÝYONUN RETURN'ÜNE EÞÝTLERSÝN.
BÜTÜN FONKSÝYONLARIN RETURN'Ü VARDIR.
SEN BÝR FONKSÝYONA RETURN KODLAMAZSAN PYTHON OTOMATÝK OLARAK FONKSÝYONUNA BÝR RETURN VERÝR. BU RETURN NONE'DIR.

func(2)*3 ---> 18

func_2(2)*3 ---> HATA (6'yý (print'ten dolayý) yine görürüz ama hatayý alýrýz)

RETURN PRINT ETMEZ, PRINT RETURN ETMEZ.

FONKSÝYON NEREDE ÇALIÞIRSA ÇALIÞSIN PRINT'LER BASTIRILIR.