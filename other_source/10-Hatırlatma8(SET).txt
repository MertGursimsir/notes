Bir küme, listelerden farklý olarak, belli bir sýrasý bulunmayan bir veri topluluðudur; yani elemanlarýna indeksleme ile eriþilemez. Ayrýca, matematiksel kümeler gibi, ayný elemandan birden fazla barýndýramaz.

***LÝSTE KÜMENÝN ELEMANI OLAMAZ!

s = {(1,2,3),"abc",123,-1,"abc",(1,2,3)}
s
|
{'abc', 123, -1, (1, 2, 3)}



set([1,3,1,-2,"abc", "abc"])
|
{1, 'abc', 3, -2}



set("ananas")
|
{'a', 'n', 's'}



Bir kümedeki elemanlarýn hashable olabilmesi, yani bir hash fonksiyonuna verilebilmesi gerekir. Bu da genellikle deðiþtirilemez (immutable) veri tipleri olmalarýný gerektirir. Sayýlar, çokuzlar, dizeler küme elemaný olmaya uygundurlar. Buna karþýlýk listeler, sözlükler ve kümeler, küme elemaný olamazlar (evet, matematiksel tanýmda kümeler baþka kümelerin elemaný olabilir, ama Python’da teknik sebeplerle bu mümkün olmaz).



Boþ küme için set() fonksiyonu tek baþýna kullanýlmalýdýr. Boþ küme parantezleri {} kullanmak boþ bir sözlük oluþturur, küme deðil.


EÞÝTLÝK ==
EÞÝT DEÐÝL !=
ALT KÜME <=
ÖZ ALT KÜME <
KAPSAMA > / >=
BÝLEÞÝM |
KESÝÞÝM &
FARK -
SÝMETRÝK FARK ^    --->  A^B == (A|B) - (A&B)

---------------------------------------------------------------------------------------------
Donuk Kümeler
Bir kere tanýmlanýnca deðiþtirilemez. 
Deðiþtirilemezlik sayesinde hashable nesnelerdir. Böylece sözlüklerde anahtar olarak kullanýlabilirler, veya küme elemaný olabilirler.


s = frozenset((1,2,"abc",frozenset("abc")))
s
|
frozenset({frozenset({'a', 'b', 'c'}), 1, 2, 'abc'})

Buradan sonraki iþlemler kümelerde deðiþiklik yapmak için kullanýlýr yani donuk olmayan kümeler içindir.
---------------------------------------------------------------------------------------------


s = set()
s.add(1)
s.add("abc")
s.add(2)
s.add(1)
s
|
{1, 'abc', 2}


s.remove(2)
s
|
{1, 'abc'}


s.remove(2)
|
HATA

s.discard(2) metodu hata vermez.



s.clear()
s
|
set()



s = {1,"abc",(1,2,3)}
s.pop(), s.pop(), s.pop()
|
(1, 'abc', (1, 2, 3))

s.pop()
|
HATA



Sayýlarda ve listelerde +=, *= gibi güncelleme iþlemleri olduðunu görmüþtük. Kümelerde de, yukarýda gördüðümüz bileþim, kesiþim, fark, simetrik fark iþlemlerini |=, &=, -=, ^= yapýlarýyla güncelleme iþlemi haline getirmek mümkün.


s1 = set(range(5))
s2 = set(range(2,7))
s1, s2
|
({0, 1, 2, 3, 4}, {2, 3, 4, 5, 6})



s1 |= s2        #s1=s1|s2 ile ayný
s1,s2
|
({0, 1, 2, 3, 4, 5, 6}, {2, 3, 4, 5, 6})


s1 = set(range(5))
s1 &= s2        #s1=s1&s2 ile ayný
s1
|
{2, 3, 4}


s1 = set(range(5))
s1 -= s2        #s1=s1-s2 ile ayný
s1
|
{0, 1}


s1 = set(range(5))
s1 ^= s2   #s1=s1^s2 ile ayný
s1
|
{0, 1, 5, 6}



MÜKERRER ELEMANLARI KALDIRMAK
-----------------------------
L = [1,2,3,4,1,2,3,4,1,3,2,1,4,1,2,1,3,1]
list(set(L))
|
[1, 2, 3, 4]


dize = "korkma sönmez bu þafaklarda yüzen al sancak"
"".join(sorted(set(dize)))
|
' abcdefklmnorsuyzöüþ'



ELEMANIN VARLIÐINI TEST ETMEK
-----------------------------
Bir kümede belli bir elemanýn mevcudiyetini test etmek, listede test etmekten çok daha hýzlýdýr. Bunun sebebi, bir eleman aranýrken listenin baþtan sona taranmasýdýr. Bu yüzden, liste uzadýkça listede bir elemanýn varlýðýnýn tespiti için gereken zaman artar. Kümelerde ise hash fonksiyonu kullanarak bir tek iþlemde test yapýlabilir; iþlem kümedeki eleman sayýsýna baðlý deðildir.


from random import randint
L = list(range(1,1000001))
s = set(L)


%%timeit
n = randint(1,2000000)
n in L
|
13.4 ms ± 1.08 ms per loop (mean ± std. dev. of 7 runs, 100 loops each)


%%timeit
n = randint(1,2000000)
n in s
|
2.08 µs ± 68.5 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)



D = dict.fromkeys(L)
D
|
{1: None,
 2: None,
 3: None,
 4: None,
 5: None,
 6: None,
 7: None,...}


%%timeit
n = randint(1,2000000)
n in D
2.71 µs ± 247 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

Sözlüklerde eleman tespiti kümelerdeki kadar hýzlýdýr, çünkü sözlüklerde de anahtarlar hash fonksiyonlarýyla aranýr. Bütün sözlük elemanlarýný taramak gerekmez. Yaptýðýmýz zaman ölçümü de bunu gösteriyor.