Python dinamik tabir edilen dillerden biridir; programdaki nesneleri önceden bildirmeniz gerekmez, program çalýþtýkça iþlenen komutlar o anda yeni nesneler üretir. Bu dinamiklik sayesinde, dize olarak verilmiþ Python komutlarýný da iþleyebilir, hatta program yazan programlar yazabiliriz.

Bu iþlemi yapmak için iki Python fonksiyonu vardýr: eval() ve exec()


EVAL
----
DEÐER DÖNDÜREN ÝFADELERÝ ÝÞLER

Python komutlarý içeren bir dizeyi yorumlayýcýya gönderir ve sonucu geri verir.


eval("2**3 + 4*5")
|
28


x = 5
eval("2*x+4")
|
14


Deðiþkeni baþka bir deðerle kullanmak isterseniz, deðiþkenleri bir sözlük ile verebilirsiniz.

eval("2*x+4",{"x":10})
|
24



Bir metodla ilgili bilgi almak için help() komutunu kullandýðýmýzda o metodun (bir fonksiyon nesnesidir) __doc__ isimli özelliði ekrana basýlýr. Buna doðrudan da eriþebiliriz.

list.append.__doc__
|
'Append object to the end of the list.'



Nesne sýnýfý altýnda tanýmlanmýþ bütün metodlarýn belge dizesini ekrana dökmek istiyoruz ama altçizgi bulunmayanlarý:

for metod in dir(list):
    if "__" not in metod:
        print(eval("list."+metod+".__doc__"))
|
Append object to the end of the list.
Remove all items from list.
Return a shallow copy of the list.
Return number of occurrences of value.
Extend list by appending elements from the iterable.
Return first index of value.

Raises ValueError if the value is not present.
Insert object before index.
Remove and return item at index (default last).

Raises IndexError if list is empty or index is out of range.
Remove first occurrence of value.

Raises ValueError if the value is not present.
Reverse *IN PLACE*.
Stable sort *IN PLACE*.






EXEC
----
Bir ifade (expression) olmayan, yani deðer döndürmeyen komutlarý (söz geliþi fonksiyon tanýmlarý, döngüler, atamalar vb.) çalýþtýrmak için exec() fonksiyonuna ihtiyacýmýz var.

exec("x=3.1415")
x
|
3.1415

Bir formülde deðiþkene 0-9 arasý deðerler vererek bir tablo oluþturan bir kod yazalým. Formülü kullanýcýdan alalým.

deðiþken = "x" # Formülde kullanýlacak deðiþken.
formül = input("Bir matematiksel formül yazýn: ")
kod = """
for {0} in range(10):
    print({0}, {1})""".format(deðiþken, formül)
print(kod)
|
Bir matematiksel formül yazýn: 2*x**3-10

for x in range(10):
    print(x, 2*x**3-10)



exec(kod)
|
0 -10
1 -8
2 6
3 44
4 118
5 240
6 422
7 676
8 1014
9 1448


Farkedeceðiniz gibi, deðiþken‘in deðeri "x" olduðu için formülde de x karakterini kullanmamýz gerekiyor. Ama deðiþken‘e farklý bir deðer atayarak formülde farklý bir deðiþken adý kullanmamýz mümkün olur.



GLOBAL VE YEREL DEÐÝÞKENLER
---------------------------
eval/exec fonksiyonlarý, iþletilecek kodu barýndýran dizenin yaný sýra iki parametre daha alýrlar: globals ve locals. Bu parametreler özellikle belirtilmezse, eval/exec kodunda yorumlayýcýnýn o andaki durumunda tanýmlanmýþ olan bütün isimler kullanýlabilir.


Yerel deðiþkenler bir fonksiyon içinden tanýmlý olan, o fonksiyonun dýþýnda tanýnmayan isimlerdir. Global deðiþkenler ise bütün fonksiyonlarýn eriþebileceði deðiþkenlerdir. Yerel isimlere locals(), global isimlere ise globals() komutlarýyla ulaþýlabilir. Bu komutlar deðiþken isimleriyle deðerlerini eþleþtiren birer sözlük döndürür.


def f(x):
    a = 10
    print(locals())
f(3)
|
{'a': 10, 'x': 3}



eval/exec ile bir kod parçasý çalýþtýrýrken bu global ve yerel deðiþkenleri sýnýrlandýrabiliriz. Bu fonksiyonlarýn genel kullanýmý þöyledir:
eval(source, globals=None, locals=None)
exec(source, globals=None, locals=None)


Burada globals ve locals parametreleri olarak global ve yerel deðiþkenleri tutan birer sözlük koyabiliriz.

exec("print(locals())", None, {"abc": 17, "xyz": "Mehmet"})
|
{'abc': 17, 'xyz': 'Mehmet'}

exec("print(globals())", None, {"abc": 17, "xyz": "Mehmet"})
|
{'__name__': '__main__', ... '__builtins__': <module 'builtins' (built-in)>, ... '_i14': 'exec("print(globals())", None, {"abc": 17, "xyz": "Mehmet"})'}


globals yerine boþ bir sözlük koyarsak sadece Python dilinin parçasý olarak tanýmlanmýþ isimlere eriþilebilir.

exec("print(globals())", {}, {"abc": 17, "xyz": "Mehmet"})
|
{'__builtins__': {'__name__': 'builtins', ... 'abs': <built-in function abs>, 'all': <built-in function all>, 'any': <built-in function any>, ...}


Bunlara bile eriþimi kapatmamýz mümkündür, aþaðýdaki bölümde göreceðimiz gibi.

GÜVENLÝK
--------
Dýþarýdan alýnan bir kodu çalýþtýrmak her zaman risklidir. exec() ve eval() fonksiyonlarýnýn bilgisayarýnýza bir kapý açtýðýný unutmayýn.

Tehlikeyi örneklemek için, yukarýdaki örneði tekrar ele alalým. Siz bir formül beklerken, kötü niyetli bir kullanýcý iþletim sisteminizi yönetecek bir komutu bu formülle beraber verebilir. Meselâ, formül sorulduðunda

'x); import os; os.system("touch hello.world");(0,'

dizesinin verildiðini varsayalým.


deðiþken = "x" # Formülde kullanýlacak deðiþken.
formül = 'x); import os; os.system("touch hello.world");(0,'
kod = """
for {0} in range(10):
    print({0}, {1})""".format(deðiþken, formül)


Bu girdi sonucunda çalýþtýrýlacak kod þöyle olur:

print(kod)
|
for x in range(10):
    print(x, x); import os; os.system("touch hello.world");(0,)


Burada kötü niyetli kullanýcý beklenen formülü verdikten sonra parantezi kapatmýþ ve iþletim sistemine yönelik komutlar eklemiþ. (Sondaki (0, kýsmý, kalýpta bulunan sað parantezin sentaks hatasý vermemesi için, onu etkisiz eleman haline dönüþtürüyor.)

Bu kodu exec(kod) ile çalýþtýrdýðýnýzda ekrana sayýlar tablosu çýkmasýnýn yaný sýra, bu programý çalýþtýrdýðýnýz dizinin altýnda hello.world isimli boþ bir dosya yaratýldýðýný göreceksiniz (Linux kullanýyorsanýz). Yani program iþletim sisteminize eriþebildi. Kötü niyetli bir saldýrgan ayný yöntemle diskinizi silebilir, þifrelerinizi çalabilir, virüs yerleþtirebilir.

Bu risklere karþý alýnabilecek kýsmi tedbirler vardýr. En yaygýn olaný, exec‘in çalýþtýðý sanal ortamdaki deðiþkenleri, globals ve locals parametreleri kullanarak düzenlemektir. Sözgeliþi aþaðýda, globals parametresi olarak {"__builtins__":None} vermekle Python’un öntanýmlý fonksiyonlarýný kapatýrýz. Böylelikle import ile bir modül yüklenmesini ve iþletim sistemine ulaþýlmasýný engelleriz. Bu iþlem range ve print fonksiyonlarýný da kapatýr, o yüzden locals parametresine bunlarýn tanýmlarýný içeren bir sözlük veririz.


exec(kod, {"__builtins__":None}, {"range":range, "print":print})
|
0 0
---------------------------------------------------------------------------
ImportError                               Traceback (most recent call last)
<ipython-input-53-dc96600e9141> in <module>
----> 1 exec(kod, {"__builtins__":None}, {"range":range, "print":print})

<string> in <module>

ImportError: __import__ not found



Bu yeni düzende import fonksiyonu tanýnmadýðý için exec() çaðrýsý bir hata verdi ve sýzma engellendi. Ayný kodu beklenen þekilde bir girdiyle çalýþtýrdýðýnýzda ise sorun yaþamazsýnýz.

Matematik kütüphanesindeki fonksiyonlarý kullanan iþlemler yapmak istiyorsanýz, gereken fonksiyonlardan oluþan bir “beyaz liste” oluþturabilirsiniz.

deðiþken = "x" # Formülde kullanýlacak deðiþken.
formül = "x * sqrt(x+1)/log(x+2)"
kod = """
for {0} in range(10):
    print({0}, {1})""".format(deðiþken, formül)

import math
exec(kod, {"__builtins__":None}, {"range":range, "print":print, "sqrt":math.sqrt, "log":math.log})
|
0 0.0
1 1.2872726592996706
2 2.4988211106473432
3 3.728009607357671
4 4.991893199734352
5 6.293943592339911
6 7.6340245917967176
7 9.010908615097694
8 10.423067565678043
9 11.868949934707404


Özetle, dinamik olarak üretilen bir kodu iþletmek için exec/eval kullanabilirsiniz. Bunun yararlý, hatta elzem olduðu çeþitli durumlar vardýr. Söz geliþi

-Python sözdizimiyle yazýlmýþ bir ifadeyi doðrudan alýp iþlemek,
-Bir konfigürasyon dosyasýný herhangi bir “parsing” iþlemine tabi tutmadan yorumlamak,
-Bir programýn kaynak koduna dokunmadan ek modüller yüklemek.

exec/eval ilk bakýþta çok hoþ görünseler de çok sýk kullanýlmamalýdýrlar, bazý sakýncalarý vardýr.

-Kodu okumayý zorlaþtýrýr. Programý anlamak istiyorsak kaynak koduna ek olarak, çalýþtýrýlmak üzere alýnacak kodun ne olduðunu da bilmeliyiz.
-Kodu test etmeyi, hatalarý bulmayý zorlaþtýrýr.
-Güvenlik açýðý oluþturur.

exec/eval fonksiyonlarýnýn iþe yaradýðý durumlar vardýr, ama probleminizi önce normal kod kullanarak çözmeye çalýþýn.


